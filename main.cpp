/*
 * 25/11/2015 : kostasl Testing OpenCV bg substraction - to process larva in vial recording timelapses.
 * App uses BG substyraction MOG2, with a slow learning rate.
 * then Uses Open and Close / Dilation contraction techniques to get rid of noise and fill gaps
 * //Next is to detect/Count Larva on screen use some Form of Particle Filter, concentration filter.
 *
 */
#include <iostream>
#include <sstream>

#include <QApplication>
#include <QQmlApplicationEngine>
#include <QDir>
#include <QFileDialog>
#include <QTextStream>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/video.hpp>
#include "opencv2/video/background_segm.hpp"


#include <cvblob.h>

cv::Mat frame; //current frame
cv::Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
cv::Mat fgMaskGMG; //fg mask fg mask generated by GMG method
cv::Ptr<cv::BackgroundSubtractor> pMOG; //MOG Background subtractor
cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
cv::Ptr<cv::BackgroundSubtractor> pGMG; //GMG Background subtractor

//Global Shortcut of Type conversion to legacy IplImage
IplImage  *labelImg;
IplImage frameImg;

int keyboard; //input from keyboard
int screenx,screeny;
using namespace std;

void processVideo(QString videoFilename,QString outFileCSV);
void checkPauseRun(int& keyboard,string frameNumberString);
bool saveImage(string frameNumberString,cv::Mat& img);
int countObjectsviaContours(cv::Mat& srcimg );
int countObjectsviaBlobs(cv::Mat& srcimg,cvb::CvBlobs& blobs);
int saveTrackedBlobs(cvb::CvBlobs& blobs,QString filename,string frameNumber);
int saveTracks(cvb::CvTracks& tracks,QString filename,std::string frameNumber);

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QQmlApplicationEngine engine;

    QString invideoname = QFileDialog::getOpenFileName(0, "Select timelapse video to Process", qApp->applicationDirPath(), "Video file (*.mpg *.avi)", 0, 0); // getting the filename (full path)
    QString outfilename = QFileDialog::getSaveFileName(0, "Save XY to output", "dataOut.csv", "CSV files (*.csv);", 0, 0); // getting the filename (full path)


    //Getting the screen information
    //screenx = GetSystemMetrics(SM_CXSCREEN);
    //screeny = GetSystemMetrics(SM_CYSCREEN);

    //engine.load(QUrl(QStringLiteral("qrc:///main.qml")));

    // get the applications dir path and expose it to QML

       //create GUI windows
       cv::namedWindow("Frame");
       //create Background Subtractor objects
              //(int history=500, double varThreshold=16, bool detectShadows=true
       pMOG2 =  new cv::BackgroundSubtractorMOG2(30,16,false); //MOG2 approach
       //(int history=200, int nmixtures=5, double backgroundRatio=0.7, double noiseSigma=0)
       //pMOG =  new cv::BackgroundSubtractorMOG(30,12,0.7,0.0); //MOG approach
       //pGMG =  new cv::BackgroundSubtractorGMG(); //GMG approach

       //"//home/kostasl/workspace/QtTestOpenCV/pics/20151124-timelapse.mpg"
       processVideo(invideoname,outfilename);


       //destroy GUI windows
       cv::destroyAllWindows();

       cv::waitKey(0);                                          // Wait for a keystroke in the window


       //pMOG->~BackgroundSubtractor();
       pMOG2->~BackgroundSubtractor();
       //pGMG->~BackgroundSubtractor();

       std::exit(0);
       return EXIT_SUCCESS;
    //return app.exec();
}


/*
 * Process Larva timelapse, removing BG, detecting moving larva- Setting the learning rate will change the time required
 * to remove a pupa from the scene -
 */

void processVideo(QString videoFilename,QString outFileCSV) {
    //Speed that stationary objects are removed
    double dLearningRate = 0.00015;
    //For Morphological Filter
    //cv::Size sz = cv::Size(3,3);
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(3,3),cv::Point(-1,-1));
    cv::Mat kernelClose = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2,2),cv::Point(-1,-1));

    //Structure to hold blobs
    cvb::CvBlobs blobs;


    //create the capture object
    cv::VideoCapture capture(videoFilename.toStdString());
    if(!capture.isOpened()){
        //error in opening the video input
        std::cerr << "Unable to open video file: " << videoFilename.toStdString() << std::endl;
        std::exit(EXIT_FAILURE);
    }

    cvb::CvTracks tracks;
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            std::cerr << "Unable to read next frame." << std::endl;
            std::cerr << "Exiting..." <<  std::endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
        pMOG2->operator()(frame, fgMaskMOG2,dLearningRate);
        //pMOG->operator()(frame, fgMaskMOG);
        //pGMG->operator ()(frame,fgMaskGMG);
        //get the frame number and write it on the current frame
         //cv::imshow("FG Mask MOG 2 Before MoRPH", fgMaskMOG2);

        //Apply Open Operation
         cv::morphologyEx(fgMaskMOG2,fgMaskMOG2, cv::MORPH_OPEN, kernel,cv::Point(-1,-1),1);
         cv::morphologyEx(fgMaskMOG2,fgMaskMOG2, cv::MORPH_CLOSE, kernel,cv::Point(-1,-1),1);
         //cv::dilate(fgMaskMOG2,fgMaskMOG2,kernelClose, cv::Point(-1,-1),1);
        cv::erode(fgMaskMOG2,fgMaskMOG2,kernelClose, cv::Point(-1,-1),1);

        //Put Info TextOn Frame
        //Frame Number
        std::stringstream ss;
        cv::rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CV_CAP_PROP_POS_FRAMES);
        std::string frameNumberString = ss.str();
        cv::putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

        //Count on Original Frame
        std::stringstream strCount;
        strCount << "N:" << ((int)tracks.size());

        cv::rectangle(frame, cv::Point(540, 2), cv::Point(690,20), cv::Scalar(255,255,255), -1);
        cv::putText(frame, strCount.str(), cv::Point(545, 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));


        cvb::CvBlobs blobs;
        countObjectsviaBlobs(fgMaskMOG2, blobs);

        const int inactiveFrameCount = 10; //Number of frames inactive until track is deleted
        cvb::cvUpdateTracks(blobs,tracks, 25, inactiveFrameCount,2);
        cvb::cvRenderTracks(tracks, &frameImg, &frameImg);


        //saveTrackedBlobs(blobs,outFileCSV,frameNumberString);
        saveTracks(tracks,outFileCSV,frameNumberString);
        //Use Contours To measure Larvae
        //countObjectsviaContours(fgMaskMOG2);
        //show the current frame and the fg masks
        cv::imshow("Frame", frame);


        //cv::imshow("FG Mask MOG 1", fgMaskMOG);
        cv::imshow("FG Mask MOG 2 after Morph", fgMaskMOG2);
        //cv::imshow("FG Mask GMG ", fgMaskGMG);

        //get the input from the keyboard
        keyboard = cv::waitKey( 30 );

        checkPauseRun(keyboard,frameNumberString);


    } //main While loop
    //delete capture object
    capture.release();
}

void checkPauseRun(int& keyboard,string frameNumberString)
{
    //implemend Pause
    if ((char)keyboard == 'p')
        while ((char)keyboard != 'r')
        {
            int ms = 20;
            struct timespec ts = { ms / 1000, (ms % 1000) * 1000 * 1000 };
            nanosleep(&ts, NULL);
            //Wait Until Key to unpause is pressed
            keyboard = cv::waitKey( 30 );

            if ((char)keyboard == 's')
            {
               saveImage(frameNumberString,frame);
            }

            //if ((char)keyboard == 'c')

        }
}

bool saveImage(string frameNumberString,cv::Mat& img)
{

    //Save Output BG Masks
    QString imageToSave =   QString::fromStdString( "output_MOG_" + frameNumberString + ".png");
    QString dirToSave = qApp->applicationDirPath();

    dirToSave.append("/pics/");
    imageToSave.prepend(dirToSave);

    if (!QDir(dirToSave).exists())
    {
        cerr << "Make directory " << dirToSave.toStdString() << std::endl;
        QDir().mkpath(dirToSave);
    }

    bool saved = cv::imwrite(imageToSave.toStdString(), img);
    if(!saved) {
        cv::putText(img,"Failed to Save " + imageToSave.toStdString(), cv::Point(25, 25), cv::FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(250,250,250));
        cv::putText(img,"Failed to Save" + imageToSave.toStdString(), cv::Point(25, 25), cv::FONT_HERSHEY_SIMPLEX, 0.4 , cv::Scalar(0,0,0));
        cerr << "Unable to save " << imageToSave.toStdString() << endl;
    }
    else
    {
     cout << "Saved image " << imageToSave.toStdString() <<endl;
    }

    cv::imshow("Saved Frame", img);

}

int countObjectsviaContours(cv::Mat& srcimg )
{
     cv::Mat imgTraced;
     srcimg.copyTo(imgTraced);
     vector< vector <cv::Point> > contours; // Vector for storing contour
     vector< cv::Vec4i > hierarchy;

     cv::findContours( imgTraced, contours, hierarchy,CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE ); // Find the contours in the image
     for( int i = 0; i< contours.size(); i=hierarchy[i][0] ) // iterate through each contour.
        {
          cv::Rect r= cv::boundingRect(contours[i]);
          cv::rectangle(imgTraced,r, cv::Scalar(255,0,0),1,8,0);
          cv::rectangle(frame,r, cv::Scalar(255,0,0),1,8,0);
        }

     //Write text For Count on Original Frame
     std::stringstream strCount;
     strCount << "N:" << ((int)contours.size());

     cv::rectangle(frame, cv::Point(540, 2), cv::Point(690,20), cv::Scalar(255,255,255), -1);
     cv::putText(frame, strCount.str(), cv::Point(545, 15),
             cv::FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

    std::cout << " Larvae  "<< strCount.str() << endl;
    //imshow("Contoured Image",frame);


    // To get rid of the smaller object and the outer rectangle created
      //because of the additional mask image we enforce a lower limit on area
      //to remove noise and an upper limit to remove the outer border.

 /* if (contourArea(contours_poly[i])>(mask.rows*mask.cols/10000) && contourArea(contours_poly[i])<mask.rows*mask.cols*0.9){
      boundRect[i] = boundingRect( Mat(contours_poly[i]) );
      minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );
      circle(drawing,center[i], (int)radius[i], Scalar(255,255,255), 2, 8, 0);
      rectangle(drawing,boundRect[i], Scalar(255,255,255),2,8,0);
      num_object++;
}
      */

}


int countObjectsviaBlobs(cv::Mat& srcimg,cvb::CvBlobs& blobs)
{

    cvb::CvTracks tracks;
    ///// Finding the blobs ////////
    // get blobsq
    IplImage fgMaskImg =  srcimg;
    frameImg =  frame; //Convert The Global frame to lplImage
    cv::Mat frameLabel(fgMaskMOG2.cols,fgMaskMOG2.rows,CV_8S);
    //fgMaskMOG2.copyTo(frameLabel);
    //IplImage labelImg =  frameLabel;

    IplImage  *labelImg=cvCreateImage(cvSize(frameImg.width,frameImg.height), IPL_DEPTH_LABEL, 1);

    unsigned int result = cvb::cvLabel( &fgMaskImg, labelImg, blobs );

    //Filtering the blobs
    cvb::cvFilterByArea(blobs,10,100);

    // render blobs in original image
    //cvb::cvRenderBlobs( labelImg, blobs, &fgMaskImg, &frameImg,CV_BLOB_RENDER_COLOR|CV_BLOB_RENDER_CENTROID|CV_BLOB_RENDER_BOUNDING_BOX );



    //cout << strCount.str() << endl;
    // *always* remember freeing unused IplImages
    cvReleaseImage( &labelImg );


    return (int)blobs.size();

}

int saveTrackedBlobs(cvb::CvBlobs& blobs,QString filename,std::string frameNumber)
{

    QFile data(filename);
    if(data.open(QFile::WriteOnly |QFile::Append))
    {
        QTextStream output(&data);

        int cnt = 0;
        for (cvb::CvBlobs::const_iterator it=blobs.begin(); it!=blobs.end(); ++it)
        {
            cnt++;
            cvb::CvBlob cvB = *it->second;
            cvb::CvLabel cvL = it->first;

            //Printing the position information
            output << frameNumber.c_str() << "," << cnt <<","<< cvB.label << "," << cvB.centroid.x <<","<< cvB.centroid.y  <<  endl;
          }
        }
    data.close();
}


int saveTracks(cvb::CvTracks& tracks,QString filename,std::string frameNumber)
{

    QFile data(filename);
    if(data.open(QFile::WriteOnly |QFile::Append))
    {
        QTextStream output(&data);

        int cnt = 0;
        for (cvb::CvTracks::const_iterator it=tracks.begin(); it!=tracks.end(); ++it)
        {
            cnt++;
            cvb::CvTrack cvT = *it->second;
            cvb::CvLabel cvL = it->first;

            //Printing the position information +
            //+ lifetime; ///< Indicates how much frames the object has been in scene.
            //+active; ///< Indicates number of frames that has been active from last inactive period.
            //+ inactive; ///< Indicates number of frames that has been missing.
            output << frameNumber.c_str()  << "," << cvT.id << "," << cvT.centroid.x << "," << cvT.centroid.y  << "," << cvT.lifetime  << "," << cvT.active  << "," << cvT.inactive <<  endl;
          }
        }
    data.close();
}
